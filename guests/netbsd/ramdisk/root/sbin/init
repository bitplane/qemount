#!/bin/sh
export PATH=/bin:/sbin

on_exit() {
    echo "[INIT] Shutting down..."
    # exec replaces the process so we never return
    # -q = quick (don't wait for processes, but still syncs)
    exec halt -pq
}
trap on_exit EXIT

# Mount tmpfs at /dev so we can create device nodes
mount -t tmpfs tmpfs /dev

# Mount tmpfs at /tmp for scratch space
mount -t tmpfs tmpfs /tmp

# Mount procfs for debugging
mount -t procfs procfs /proc

# Create device nodes
# console=0,0  tty00/com0=8,0  tty01/com1=8,1  null=2,2
# wd*=0,*  (IDE disks: wd0a=0,0  wd1a=0,8 - minor = unit*8 + partition)
# sd*=4,*  (SCSI/virtio: sd0a=4,0)
# ld*=19,* (virtio-blk: ld0a=19,0)
mknod /dev/console c 0 0
mknod /dev/tty00 c 8 0
mknod /dev/tty01 c 8 1
mknod /dev/null c 2 2
# MAXPARTITIONS=16 on amd64: minor = unit*16 + partition
mknod /dev/wd0a b 0 0
mknod /dev/wd1a b 0 16
mknod /dev/sd0a b 4 0
mknod /dev/sd1a b 4 16
# ld devices: major=19, minor = unit*16 + partition (MAXPARTITIONS=16 on amd64)
mknod /dev/ld0a b 19 0
mknod /dev/ld1a b 19 16
mknod /dev/ld1d b 19 19
# viocon (virtio console/serial): major=364, minor=16*unit+port
mknod /dev/ttyVI00 c 364 0

# Redirect to serial console
exec >/dev/tty00 2>&1 </dev/tty00

# Set up terminal
export TERM=vt100
stty sane 2>/dev/null || true

echo ""
echo "==================================="
echo "  NetBSD qemount guest starting"
echo "==================================="
echo ""

# Mount point for user's image
MOUNT_POINT=/mnt
MOUNT_SUCCESS=0

# Try different possible devices for the user's image
# ld1 = second virtio disk (user image), ld0 = boot disk
# Try ld1d (raw) first for images without disklabel, then ld1a (partition a)
for TARGET_DEV in /dev/ld1d /dev/ld1a /dev/sd0a /dev/wd1a; do
    echo "[INIT] Trying $TARGET_DEV..."
    if mount "$TARGET_DEV" "$MOUNT_POINT" 2>/dev/null; then
        MOUNT_SUCCESS=1
        echo "[INIT] Mounted $TARGET_DEV to $MOUNT_POINT"
        break
    fi
done

if [ "$MOUNT_SUCCESS" = "0" ]; then
    echo "[INIT] No mountable image found"
fi

export MOUNT_SUCCESS
export MOUNT_POINT

# Detect mode from QEMU fw_cfg
# QEMU passes mode via: -fw_cfg name=opt/qemount/mode,string=<mode>
# Try to read from sysctl first, fall back to sh
MODE=$(sysctl -n hw.qemufwcfg.opt.qemount.mode 2>/dev/null || echo "sh")

SCRIPT="/init.${MODE}"

echo "[INIT] Dispatching to: $SCRIPT"
if [ -x "$SCRIPT" ]; then
    "$SCRIPT" || echo "[INIT] Script failed: $?"
else
    echo "[INIT] Mode script not found: $SCRIPT"
    /bin/sh -i
fi

# Script exited - trap will handle shutdown
