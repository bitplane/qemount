#!/bin/sh
export PATH=/bin:/sbin

# Filesystem types to try when auto-detect fails (override via config)
FS_TYPES="ffs cd9660 ext2fs msdos udf ntfs hfs lfs v7fs ados filecore efs"

on_exit() {
    echo "[INIT] Shutting down..."
    sync
    umount -a 2>/dev/null
    sync
    exec halt -pq
}
trap on_exit EXIT

# Mount tmpfs at /dev so we can create device nodes
mount -t tmpfs tmpfs /dev

# Mount tmpfs at /tmp for scratch space
mount -t tmpfs tmpfs /tmp

# Mount procfs for debugging
mount -t procfs procfs /proc

# Create device nodes
# console=0,0  tty00/com0=8,0  tty01/com1=8,1  null=2,2
# wd*=0,*  (IDE disks: wd0a=0,0  wd1a=0,8 - minor = unit*8 + partition)
# sd*=4,*  (SCSI/virtio: sd0a=4,0)
# ld*=19,* (virtio-blk: ld0a=19,0)
mknod /dev/console c 0 0
mknod /dev/tty00 c 8 0
mknod /dev/tty01 c 8 1
mknod /dev/null c 2 2
# MAXPARTITIONS=16 on amd64: minor = unit*16 + partition
mknod /dev/wd0a b 0 0
mknod /dev/wd1a b 0 16
mknod /dev/sd0a b 4 0
mknod /dev/sd1a b 4 16
# ld devices: major=19, minor = unit*16 + partition (MAXPARTITIONS=16 on amd64)
# ld0 = boot disk, user disks (ld1+) created dynamically in mount loop
mknod /dev/ld0a b 19 0
# viocon (virtio console/serial): major=364, minor=16*unit+port
mknod /dev/ttyVI00 c 364 0

# Need to hold fd open so stty options hold - device resets to echo mode on close
exec 3<>/dev/ttyVI00
stty -f /dev/ttyVI00 raw -echo -echoe -echoke -echoctl

# Redirect to serial console
exec >/dev/tty00 2>&1 </dev/tty00

# Set up terminal
export TERM=vt100
printf '\e[?7h'  # re-enable line wrap (disabled by seabios)

echo ""
echo "==================================="
echo "  NetBSD qemount guest starting"
echo "==================================="
echo ""

# Mount tmpfs on /mnt so we can create mount points
mount -t tmpfs tmpfs /mnt

MOUNT_POINT=/mnt
MOUNT_SUCCESS=0

# Try to mount a device, using FS_TYPES if auto-detect fails
# Usage: try_mount /dev/ld1d b
# Creates /mnt/$name, mounts, cleans up on failure
try_mount() {
    dev="$1"
    name="$2"
    mnt="/mnt/${name}"
    mkdir -p "$mnt"
    # Try auto-detect first (works for ffs/ufs)
    if mount "$dev" "$mnt" 2>/dev/null; then
        echo "[INIT] Mounted $dev -> $mnt"
        return 0
    fi
    # Try explicit filesystem types
    for fs in $FS_TYPES; do
        if mount -t "$fs" "$dev" "$mnt" 2>/dev/null; then
            echo "[INIT] Mounted $dev -> $mnt ($fs)"
            return 0
        fi
    done
    rmdir "$mnt" 2>/dev/null || true
    return 1
}

echo "[INIT] Scanning for disk images..."

# NetBSD virtio-blk uses ld* devices
# ld0 = boot disk, user disks start at ld1
# Major: ld=19, dk=168
# Minor: ld = unit*16 + partition, dk = unit number

# Map unit number to letter for mount points (1->b, 2->c, etc to match Linux)
get_letter() {
    case $1 in
        1) echo b;; 2) echo c;; 3) echo d;; 4) echo e;; 5) echo f;;
        6) echo g;; 7) echo h;; 8) echo i;; 9) echo j;; 10) echo k;;
        11) echo l;; 12) echo m;; 13) echo n;; 14) echo o;; 15) echo p;;
    esac
}

for unit in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; do
    base_minor=$((unit * 16))

    # Create whole-disk device node (partition 'd' = index 3)
    mknod /dev/ld${unit}d b 19 $((base_minor + 3)) 2>/dev/null || continue

    letter=$(get_letter $unit)

    # Use dkctl to discover wedges (partitions) for this disk
    # Kernel auto-discovers GPT/Apple partitions via DKWEDGE_AUTODISCOVER
    # Output format: "dk0: label, 12345 blocks at 1024, type: ffs"
    wedge_list=$(dkctl "ld${unit}" listwedges 2>/dev/null | grep "^dk")

    if [ -n "$wedge_list" ]; then
        # Disk has partitions - extract offset and sort, then mount each
        # Prepend offset for sorting: "1024 dk0: label, ..."
        sorted_wedges=$(echo "$wedge_list" | while read line; do
            # Extract offset from "at OFFSET," using expr
            offset=$(expr "$line" : '.*at \([0-9]*\),')
            echo "$offset $line"
        done | sort -n)

        # Mount each wedge in offset order (partition 1, 2, 3...)
        part_num=1
        # Use temp file to track success across subshell boundary
        echo "$sorted_wedges" > /tmp/wedges.$$
        while read offset line; do
            # Extract dk device name (everything before first colon)
            dk_name="${line%%:*}"
            dk_unit="${dk_name#dk}"

            # Create dk device node (major 168, minor = unit)
            mknod "/dev/$dk_name" b 168 "$dk_unit" 2>/dev/null || true

            if try_mount "/dev/$dk_name" "${letter}${part_num}"; then
                MOUNT_SUCCESS=1
            fi
            part_num=$((part_num + 1))
        done < /tmp/wedges.$$
        rm -f /tmp/wedges.$$
    else
        # No wedges - try whole disk (raw filesystem)
        if try_mount "/dev/ld${unit}d" "$letter"; then
            MOUNT_SUCCESS=1
        fi
    fi
done

if [ "$MOUNT_SUCCESS" = "0" ]; then
    echo "[INIT] No mountable images found"
fi

export MOUNT_SUCCESS
export MOUNT_POINT

# Detect mode from QEMU fw_cfg
# QEMU passes mode via: -fw_cfg name=opt/qemount/mode,string=<mode>
# Try to read from sysctl first, fall back to sh
MODE=$(sysctl -n hw.qemufwcfg.opt.qemount.mode 2>/dev/null || echo "sh")

SCRIPT="/init.${MODE}"

echo "[INIT] Dispatching to: $SCRIPT"
if [ -x "$SCRIPT" ]; then
    "$SCRIPT" || echo "[INIT] Script failed: $?"
else
    echo "[INIT] Mode script not found: $SCRIPT"
    /bin/sh -i
fi

# Script exited - trap will handle shutdown
